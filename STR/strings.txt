CADENAS DE TEXTO:

Es importante destacar que Python 3 almacena los caracteres codificados en el 
est치ndar Unicode, lo que es una gran ventaja con respecto a versiones antiguas 
del lenguaje.
Adem치s permite representar una cantidad ingente de s칤mbolos incluyendo 
los famosos emojis 游땙.

Para incluir comillas dobles dentro de la cadena de texto no hay mayor 
inconveniente:

'Los llamados "strings" son secuencias de caracteres'
'Los llamados "strings" son secuencias de caracteres'

Puede surgir la duda de c칩mo incluimos comillas simples dentro de la propia cadena de texto.
Veamos soluciones para ello:

'Los llamados \'strings\' son secuencias de caracteres'
"Los llamados 'strings' son secuencias de caracteres"


Comillas simples dentro de comillas dobles:

"Los llamados 'strings' son secuencias de caracteres"
"Los llamados 'strings' son secuencias de caracteres"

En la primera opci칩n estamos escapando las comillas simples para que no sean tratadas como caracteres especiales. 
En la segunda opci칩n estamos creando el 춺string췉 con comillas dobles (por fuera) para poder incluir directamente las comillas simples (por dentro). 
Python tambi칠n nos ofrece esta posibilidad.


Comillas triples

Hay una forma alternativa de crear cadenas de texto utilizando comillas triples. 
Su uso est치 pensado principalmente para cadenas multil칤nea:

poem = '''To be, or not to be, that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles'''

Cadena vac칤a

La cadena vac칤a es aquella que no contiene ning칰n car치cter. 
Aunque a priori no lo pueda parecer, es un recurso importante en cualquier c칩digo. 
Su representaci칩n en Python es la siguiente:

''
''

Conversi칩n:

Podemos crear 춺strings췉 a partir de otros tipos de datos usando la funci칩n str():

str(True)
'True'

str(10)
'10'

str(21.7)
'21.7'

Para el caso contrario de convertir un 춺string췉 a un valor num칠rico, 
tenemos a disposici칩n las funciones ya vistas:

int('10')
10

float('21.7')
21.7

Pero hay que tener en cuenta un detalle. 
La funci칩n int() tambi칠n admite la base en la que se encuentra el n칰mero. 
Eso significa que podemos pasar un n칰mero, por ejemplo, 
en hexadecimal (como 춺string췉) y lo podr칤amos convertir a su valor entero:

int('FF', 16)
255




Nota

La base por defecto que utiliza int() para convertir cadenas de texto es la base decimal.


Secuencias de escape

Python permite escapar el significado de algunos caracteres para conseguir otros resultados. 
Si escribimos una barra invertida \ antes del car치cter en cuesti칩n, 
le otorgamos un significado especial.
Quiz치s la secuencia de escape m치s conocida es \n que representa un salto de l칤nea, 
pero existen muchas otras:

# Salto de l칤nea
>>> msg = 'Primera l칤nea\nSegunda l칤nea\nTercera l칤nea'
>>> print(msg)
Primera l칤nea
Segunda l칤nea
Tercera l칤nea

# Tabulador
>>> msg = 'Valor = \t40'
>>> print(msg)
Valor =     40

# Comilla simple
>>> msg = 'Necesitamos \'escapar\' la comilla simple'
>>> print(msg)
Necesitamos 'escapar' la comilla simple

# Barra invertida
>>> msg = 'Cap칤tulo \\ Secci칩n \\ Encabezado'
>>> print(msg)
Cap칤tulo \ Secci칩n \ Encabezado


Nota

Al utilizar la funci칩n print() es cuando vemos realmente el resultado de utilizar los caracteres escapados.

Expresiones literales

Nivel intermedio

Hay situaciones en las que nos interesa que los caracteres especiales pierdan ese significado y poder usarlos de otra manera. 
Existe un modificar de cadena que proporciona Python para tratar el texto en bruto. 
Es el llamado 춺raw data췉 y se aplica anteponiendo una r a la cadena de texto.

Veamos algunos ejemplos:
>>>

text = 'abc\ndef'

print(text)
abc
def

text = r'abc\ndef'

print(text)
abc\ndef

text = 'a\tb\tc'

print(text)
a    b    c

text = r'a\tb\tc'

print(text)
a\tb\tc

Consejo

El modificador r'' es muy utilizado para la escritura de expresiones regulares.

M치s sobre print()

Hemos estado utilizando la funci칩n print() de forma sencilla, 
pero admite algunos par치metros interesantes:

msg1 = '쯉abes por qu칠 estoy ac치?'

msg2 = 'Porque me apasiona'

print(msg1, msg2)
쯉abes por qu칠 estoy ac치? Porque me apasiona

print(msg1, msg2, sep='|')
쯉abes por qu칠 estoy ac치?|Porque me apasiona

print(msg2, end='!!')
Porque me apasiona!!

L칤nea 4:
    Podemos imprimir todas las variables que queramos separ치ndolas por comas.
L칤nea 7:
    El separador por defecto entre las variables es un espacio, podemos cambiar el car치cter que se utiliza como separador entre cadenas.
L칤nea 10:
    El car치cter de final de texto es un salto de l칤nea, podemos cambiar el car치cter que se utiliza como final de texto.


Leer datos desde teclado

Los programas se hacen para tener interacci칩n con el usuario. 
Una de las formas de interacci칩n es solicitar la entrada de datos por teclado. 
Como muchos otros lenguajes de programaci칩n, Python tambi칠n nos ofrece la posibilidad de leer la informaci칩n introducida por teclado. 
Para ello se utiliza la funci칩n input():

name = input('Introduzca su nombre: ')
Introduzca su nombre: Sergio
name
'Sergio'
type(name)
str

age = input('Introduzca su edad: ')
Introduzca su edad: 41
age
'41'
type(age)
str



Nota

La funci칩n input() siempre nos devuelve un objeto de tipo cadena de texto o str. 
Tenerlo muy en cuenta a la hora de trabajar con n칰meros, 
ya que debemos realizar una conversi칩n expl칤cita.


OPERACIONES CON  춺strings췉:

COMBINAR CADENAS:

Podemos combinar dos o m치s cadenas de texto utilizando el operador +:

proverb1 = 'Cuando el r칤o suena'

proverb2 = 'agua lleva'

proverb1 + proverb2
'Cuando el r칤o suenaagua lleva'

proverb1 + ', ' + proverb2  # incluimos una coma
'Cuando el r칤o suena, agua lleva'


REPETIR CADENAS:

Podemos repetir dos o m치s cadenas de texto utilizando el operador *:

reaction = 'Wow'

reaction * 4
'WowWowWowWow'


OBTENER UN CARACTER:

Los 춺strings췉 est치n indexados y cada car치cter tiene su propia posici칩n. 
Para obtener un 칰nico car치cter dentro de una cadena de texto es necesario especificar su 칤ndice dentro de corchetes [...].

-11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1
 H   o   l  a  ,     M  u  n  d  o
 0   1   2  3  4  5  6  7  8  9  10

Veamos algunos ejemplos de acceso a caracteres:    

sentence = 'Hola, Mundo'

sentence[0]
'H'

sentence[-1]
'o'

sentence[4]
','

sentence[-5]
'M'



Truco

N칩tese que existen tanto 칤ndices positivos como 칤ndices negativos para acceder a cada car치cter de la cadena de texto. 
A priori puede parecer redundante, pero es muy 칰til en determinados casos.

En caso de que intentemos acceder a un 칤ndice que no existe, 
obtendremos un error por fuera de rango:

sentence[50]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range



ADVERTENCIA(ojo):

T칠ngase en cuenta que el indexado de una cadena de texto 
siempre empieza en 0 y termina en una unidad menos de la longitud de la cadena.

Las cadenas de texto son tipos de datos INMUTABLES. 
Es por ello que no podemos modificar un car치cter directamente:


song = 'Hey Jude'

song[4] = 'D'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment




Truco

Existen formas de modificar una cadena de texto que veremos m치s adelante, 
aunque realmente no estemos transformando el original sino creando un nuevo 
objeto con las modificaciones.



Advertencia

No hay que confundir las constantes con los tipos de datos inmutables. 
Es por ello que las variables que almacenan cadenas de texto, 
a pesar de ser inmutables, 
no se escriben en may칰sculas.



TROCEAR UNA CADENA :

Es posible extraer 춺trozos췉 (춺rebanadas췉) de una cadena de texto . 
Tenemos varias aproximaciones para ello:

[:]
    Extrae la secuencia entera desde el comienzo hasta el final. 
    Es una especia de copia de toda la cadena de texto.

[start:]

    Extrae desde start hasta el final de la cadena.
[:end]

    Extrae desde el comienzo de la cadena hasta end menos 1.

[start:end]

    Extrae desde start hasta end menos 1.

[start:end:step]

    Extrae desde start hasta end menos 1 haciendo saltos de tama침o step.

Veamos la aplicaci칩n de cada uno de estos accesos a trav칠s de un ejemplo:

proverb = 'Agua pasada no mueve molino'

proverb[:]
'Agua pasada no mueve molino'

proverb[12:]
'no mueve molino'

proverb[:11]
'Agua pasada'

proverb[5:11]
'pasada'

proverb[5:11:2]
'psd'



Importante

El troceado siempre llega a una unidad menos del 칤ndice final que hayamos especificado. 
Sin embargo el comienzo s칤 coincide con el que hemos puesto.

LONGITUD DE UNA CADENA 

Para obtener la longitud de una cadena podemos hacer uso de len(), 
una funci칩n com칰n a pr치cticamente todos los tipos y estructuras de datos en Python:

proverb = 'Lo cort칠s no quita lo valiente'

len(proverb)
30

empty = ''

len(empty)
0

PERTENENCIA DE UN ELEMENTO 

Si queremos comprobar que una determinada subcadena se encuentra en una cadena de texto utilizamos el operador in para ello. 
Se trata de una expresi칩n que tiene como resultado un valor 춺booleano췉 verdadero o falso:

proverb = 'M치s vale malo conocido que bueno por conocer'

'malo' in proverb
True

'bueno' in proverb
True

'regular' in proverb
False

Habr칤a que prestar atenci칩n al caso en el que intentamos descubrir 
si una subcadena no est치 en la cadena de texto:

dna_sequence = 'ATGAAATTGAAATGGGA'


'C' not in dna_sequence  # Forma pit칩nica
True

Dividir una cadena

Una tarea muy com칰n al trabajar con cadenas de texto es dividirlas por alg칰n tipo de separador. 
En este sentido, Python nos ofrece la funci칩n split(), 
que debemos usar anteponiendo el 춺string췉 que queramos dividir:

proverb = 'No hay mal que por bien no venga'

proverb.split()
['No', 'hay', 'mal', 'que', 'por', 'bien', 'no', 'venga'] #Devuelve una lista 

tools = 'Martillo,Sierra,Destornillador'

tools.split(',')
['Martillo', 'Sierra', 'Destornillador']


Nota

Si no se especifica un separador, split() 
usa por defecto cualquier secuencia de espacios en blanco, 
tabuladores y saltos de l칤nea.

Aunque a칰n no lo hemos visto, lo que devuelve split() es una lista 
(otro tipo de datos en Python) 
donde cada elemento es una parte de la cadena de texto original:


game = 'piedra-papel-tijera'

type(game.split('-'))
list

Existe una forma algo m치s avanzada de dividir una cadena a trav칠s del particionado. 
Para ello podemos valernos de la funci칩n partition() que proporciona Python.

Esta funci칩n toma un argumento como separador, 
y divide la cadena de texto en 3 partes: lo que queda a la izquiera del separador, 
el separador en s칤 mismo y lo que queda a la derecha del separador:

text = '3 + 4'

text.partition('+')
('3 ', '+', ' 4')


LIMPIAR CADENAS 

Cuando leemos datos del usuario o de cualquier fuente externa de informaci칩n, 
es bastante probable que se incluyan en esas cadenas de texto, 
caracteres de relleno 3 al comienzo y al final. 
Python nos ofrece la posibilidad de eliminar estos caracteres u otros que no nos interesen.

La funci칩n strip() se utiliza para eliminar caracteres del principio y del final de un 춺string췉. 
Tambi칠n existen variantes de esta funci칩n para aplicarla 칰nicamente al comienzo o 칰nicamente al final de la cadena de texto.

Supongamos que debemos procesar un fichero con n칰meros de serie de un determinado art칤culo. 
Cada l칤nea contiene el valor que nos interesa pero se han 춺colado췉 ciertos caracteres de relleno que debemos limpiar:

serial_number = '\n\t   \n 48374983274832    \n\n\t   \t   \n'

serial_number.strip()
'48374983274832'


Nota

Si no se especifican los caracteres a eliminar, 
strip() usa por defecto cualquier combinaci칩n de espacios en blanco, 
saltos de l칤nea \n y tabuladores \t.

A continuaci칩n vamos a hacer 춺limpieza췉 por la 
izquierda (comienzo) y por la derecha (final) 
utilizando la funci칩n lstrip() y rstrip() respectivamente:

춺Left strip췉

serial_number.lstrip()
'48374983274832    \n\n\t   \t   \n'

춺Right strip췉

serial_number.rstrip()
'\n\t   \n 48374983274832'

Como hab칤amos comentado, 
tambi칠n existe la posibilidad de especificar los caracteres que queremos borrar:

serial_number.strip('\n')
'\t   \n 48374983274832    \n\n\t   \t   '

REALIZAR BUSQUEDAS:

Aunque hemos visto que la forma pit칩nica de saber si una subcadena se encuentra dentro de otra es a trav칠s del operador in, 
Python nos ofrece distintas alternativas para realizar b칰squedas en cadenas de texto.

Vamos a partir de una variable que contiene un trozo 
de la canci칩n Mediterr치neo de Joan Manuel Serrat para ejemplificar las 
distintas opciones que tenemos:

lyrics = '''Quiz치s porque mi ni침ez
Sigue jugando en tu playa
Y escondido tras las ca침as
Duerme mi primer amor
Llevo tu luz y tu olor
Por dondequiera que vaya'''

Comprobar si una cadena de texto empieza o termina por alguna subcadena:

lyrics.startswith('Quiz치s')
True

lyrics.endswith('Final')
False

Encontrar la primera ocurrencia de alguna subcadena:

lyrics.find('amor')
93

lyrics.index('amor')  # Same behaviour?
93

Tanto find() como index() devuelven el 칤ndice de la primera ocurrencia de la subcadena que estemos buscando, 
pero se diferencian en su comportamiento cuando la subcadena buscada no existe:

lyrics.find('universo') #DEVUELVE -1
-1

lyrics.index('universo') #DEVUELVE substring not found
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found

Contabilizar el n칰mero de veces que aparece una subcadena:

lyrics.count('mi')
2

lyrics.count('tu')
3

lyrics.count('칠l')
0

REEMPLAZAR ELEMENTOS:

Reemplazar elementos

Podemos usar la funci칩n replace() indicando la subcadena a reemplazar, 
la subcadena de reemplazo y cu치ntas instancias se deben reemplazar. 
Si no se especifica este 칰ltimo argumento, 
la sustituci칩n se har치 en todas las instancias encontradas:

proverb = 'Quien mal anda mal acaba'

proverb.replace('mal', 'bien')
'Quien bien anda bien acaba'

proverb.replace('mal', 'bien', 1)  # s칩lo 1 reemplazo
'Quien bien anda mal acaba'

MAYUSCULAS Y MINUSCULAS:

Python nos permite realizar variaciones en los caracteres de una cadena de texto para pasarlos a may칰sculas y/o min칰sculas. 
Veamos las distintas opciones disponibles:
proverb = 'quien a buen 치rbol se arrima Buena Sombra le cobija'

proverb
'quien a buen 치rbol se arrima Buena Sombra le cobija'

proverb.capitalize()
'Quien a buen 치rbol se arrima buena sombra le cobija'

proverb.title()
'Quien A Buen 츼rbol Se Arrima Buena Sombra Le Cobija'

proverb.upper()
'QUIEN A BUEN 츼RBOL SE ARRIMA BUENA SOMBRA LE COBIJA'

proverb.lower()
'quien a buen 치rbol se arrima buena sombra le cobija'

proverb.swapcase()
'QUIEN A BUEN 츼RBOL SE ARRIMA bUENA sOMBRA LE COBIJA'

IDENTIFICANDO CARACTERES:

Hay veces que recibimos informaci칩n textual de distintas fuentes de las que necesitamos identificar qu칠 tipo de caracteres contienen. Para ello Python nos ofrece un grupo de funciones.

Veamos algunas de estas funciones:
Detectar si todos los caracteres son letras o n칰meros

'R2D2'.isalnum()
True

'C3-PO'.isalnum()
False

Detectar si todos los caracteres son n칰meros

'314'.isnumeric()
True

'3.14'.isnumeric()
False

Detectar si todos los caracteres son letras

'abc'.isalpha()
True

'a-b-c'.isalpha()
False

Detectar may칰sculas/min칰sculas

'BIG'.isupper()
True

'small'.islower()
True

'First Heading'.istitle()
True

INTERPOLACI칐N DE CADENAS :

En este apartado veremos c칩mo interpolar valores dentro de cadenas de texto utilizando diferentes formatos. 
Interpolar (en este contexto) significa sustituir una variable por su valor dentro de una cadena de texto.

Supongamos que disponemos de los datos de una persona y queremos formar una frase de bienvenida con ellos:

name = 'Elon Musk'

age = 49

fortune = 43_300

f'Me llamo {name}, tengo {age} a침os y una fortuna de {fortune} millones'
'Me llamo Elon Musk, tengo 49 a침os y una fortuna de 43300 millones'

Podr칤a surgir la duda de c칩mo incluir llaves dentro de la cadena de texto, teniendo en cuenta que las llaves son s칤mbolos especiales para la interpolaci칩n de variables. La respuesta es duplicar las llaves:
>>>

x = 10

f'The variable is {{ x = {x} }}'
'The variable is { x = 10 }'

FORMATEADO DE CADENAS 

os 춺f-strings췉 proporcionan una gran variedad de opciones de formateado: 
ancho del texto, 
n칰mero de decimales, tama침o de la cifra, alineaci칩n, etc. 
Muchas de estas facilidades se pueden consultar en el art칤culo Best of Python3.6 f-strings 4

Dando formato a valores enteros:

mount_height = 3718

f'{mount_height:10d}'
'      3718'

f'{mount_height:010d}'
'0000003718'

Dando formato a otras bases:

value = 0b10010011

f'{value}'
'147'

f'{value:b}'
'10010011'

value = 0o47622

f'{value}'
'20370'

f'{value:o}'
'47622'

value = 0xab217

f'{value}'
'700951'

f'{value:x}'
'ab217'

Dando formato a valores flotantes:

pi = 3.14159265

f'{pi:f}'  # 6 decimales por defecto (se rellenan con ceros si procede)
'3.141593'

f'{pi:.3f}'
'3.142'

f'{pi:12f}'
'    3.141593'

f'{pi:7.2f}'
'   3.14'

f'{pi:07.2f}'
'0003.14'

f'{pi:.010f}'
'3.1415926500'

f'{pi:e}'
'3.141593e+00'

Alineando valores:

text1 = 'how'

text2 = 'are'

text3 = 'you'

f'{text1:<7s}|{text2:^11s}|{text3:>7s}'
'how    |    are    |    you'

f'{text1:-<7s}|{text2:췅^11s}|{text3:->7s}'
'how----|췅췅췅췅are췅췅췅췅|----you'

Modo 춺debug췉
A partir de Python 3.8, los 춺f-strings췉 permiten imprimir el nombre de la variable y su valor, como un atajo para depurar nuestro c칩digo. 
Para ello s칩lo tenemos que incluir un s칤mbolo = despu칠s del nombre de la variable:

serie = 'The Simpsons'

imdb_rating = 8.7

num_seasons = 30

f'{serie=}'
"serie='The Simpsons'"

f'{imdb_rating=}'
'imdb_rating=8.7'

f'{serie[4:]=}'  # incluso podemos a침adir expresiones!
"serie[4:]='Simpsons'"

f'{imdb_rating / num_seasons=}'
'imdb_rating / num_seasons=0.29'


Modo 춺representaci칩n췉

Si imprimimos el valor de una variable utilizando un 춺f-string췉, 
obviamente veremos ese valor tal y como esperar칤amos:

name = 'Steven Spielberg'

print(f'{name}')
Steven Spielberg

Pero si quisi칠ramos ver la representaci칩n del objeto, 
tal y como se almacena internamente, 
podr칤amos utilizar el modificador !r en el 춺f-string췉:

name = 'Steven Spielberg'

print(f'{name!r}')
'Steven Spielberg'

En este caso se han a침adido las comillas denotando que es una cadena de texto. 
Este modificador se puede aplicar a cualquier otro tipo de dato.

Caracteres Unicode

Python trabaja por defecto con caracteres Unicode. 
Eso significa que tenemos acceso a la amplia carta 
de caracteres que nos ofrece este est치ndar de codificaci칩n.

Supongamos un ejemplo sobre el t칤pico 춺emoji췉 de un cohete definido en este cuadro:



Representaci칩n Unicode del car치cter ROCKET

La funci칩n chr() permite representar un car치cter a partir de su c칩digo:

rocket_code = 0x1F680

rocket = chr(rocket_code)

rocket
'游'

La funci칩n ord() permite obtener el c칩digo (decimal) 
de un car치cter a partir de su representaci칩n:

rocket_code = hex(ord(rocket))

rocket_code
'0x1f680'

El modificador \N permite representar un car치cter a partir de su nombre:
>>>

'\N{ROCKET}'
'游'

COMPARAR CADENAS 

Cuando comparamos dos cadenas de texto lo hacemos en t칠rminos lexicogr치ficos. 
Es decir, se van comparando los caracteres de ambas cadenas uno a uno y se va mirando cu치l est치 춺antes췉.

Por ejemplo:

'arca' < 'arpa' # 'ar' es igual para ambas
True

ord('c')  La c esta primero que la p en el lugar 99 del alfabeto por eso es True que es menor 
99

ord('p')
112

Nota

Internamente se utiliza la funci칩n ord() para comparar qu칠 car치cter est치 춺antes췉.

Otros ejemplos:

'a' < 'antes'
True

'antes' < 'despu칠s'
True

'despu칠s' < 'ahora'
False

'ahora' < 'a'
False

Tener en cuenta que en Python la letras may칰sculas van antes que las min칰sculas:


'A' < 'a'
True