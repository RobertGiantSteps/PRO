[Objetos y Clases]

Hasta ahora hemos estado usando objetos de forma totalmente 
transparente, casi sin ser conscientes de ello. 
Pero, en realidad, todo en Python es un objeto, desde n√∫meros a 
funciones. El lenguaje provee ciertos mecanismos para no tener 
que usar expl√≠citamente t√©cnicas de orientaci√≥n a objetos.

[Programaci√≥n orientada a objetos]

Sus beneficios son los siguientes:

Encapsulamiento

    Permite empaquetar el c√≥digo dentro de una unidad (objeto) donde se puede determinar el √°mbito de actuaci√≥n.
Abstracci√≥n

    Permite generalizar los tipos de objetos a trav√©s de las clases y simplificar el programa.
Herencia

    Permite reutilizar c√≥digo al poder heredar atributos y comportamientos de una clase a otra.
Polimorfismo

    Permite crear m√∫ltiples objetos a partir de una misma pieza flexible de c√≥digo.

    ¬øQu√© es un objeto?

Un objeto es una estructura de datos personalizada que contiene datos y c√≥digo:

Elementos   ¬øQu√© son?   ¬øC√≥mo se llaman?    ¬øC√≥mo se identifican?

Datos       Variables       Atributos       Mediante sustantivos

C√≥digo      Funciones       M√©todos             Mediante verbos

Un objeto representa una instancia √∫nica de alguna entidad 
(a trav√©s de los valores de sus atributos) e interact√∫a con otros 
objetos (o consigo mismo) a trav√©s de sus m√©todos.

¬øQu√© es una clase?

Para crear un objeto primero debemos definir la clase que lo 
contiene. Podemos pensar en la clase como el molde con el que se 
crean nuevos objetos de ese tipo.

En el proceso de dise√±o de una clase hay que tener en cuenta ‚Äì 
entre otros ‚Äì <el principio de responsabilidad √∫nica> , 
intentando que los atributos y los m√©todos que contenga esa 
clase est√©n enfocados a un objetivo √∫nico bien definido.

[Creando objetos]

Empecemos por crear nuestra primera clase. En este caso vamos a modelar 
algunos de los droides de la saga StarWars:

Para ello usaremos la palabra reservada class seguida del nombre de la clase:

class StarWarsDroid:

    pass

Consejo:
Los nombres de clases se suelen escribir en formato 
CamelCase y en singular

Existen multitud de droides en el universo StarWars. 
Una vez que hemos definido la clase gen√©rica podemos crear 
instancias/objetos (droides) concretos:

c3po = StarWarsDroid()

r2d2 = StarWarsDroid()

bb8 = StarWarsDroid()

type(c3po)
__main__.StarWarsDroid

type(r2d2)
__main__.StarWarsDroid

type(bb8)
__main__.StarWarsDroid

A√±adiendo m√©todos

Un m√©todo es una funci√≥n que forma parte de una clase o de un 
objeto. 
En su √°mbito tiene acceso a otros m√©todos y atributos de la 
clase o del objeto al que pertenece.

La definici√≥n de un m√©todo (de instancia) es an√°loga a la de una 
funci√≥n ordinaria, pero incorporando un primer par√°metro self que 
hace referencia a la instancia actual del objeto.

Una de las acciones m√°s sencillas que se pueden hacer sobre un 
droide es encenderlo o apagarlo. 
Vamos a implementar estos dos m√©todos en nuestra clase:

class Droid:

    def switch_on(self):

        print("Hi! I'm a droid. Can I help you?")


    def switch_off(self):

        print("Bye! I'm going to sleep")

k2so = Droid()

k2so.switch_on()
Hi! I'm a droid. Can I help you?

k2so.switch_off()
Bye! I'm going to sleep

[A√±adiendo atributos]

Un atributo no es m√°s que una variable, un nombre al que 
asignamos un valor, con la particularidad de vivir dentro 
de una clase o de un objeto.

Supongamos que, siguiendo con el ejemplo anterior, 
queremos guardar en un atributo el estado del droide (encendido/apagado):

class Droid:

    def switch_on(self):
        self.power_on = True
        print("Hi! I'm a droid. Can I help you?")


    def switch_off(self):
        self.power_on = False
        print("Bye! I'm going to sleep")


k2so = Droid()

k2so.switch_on()
Hi! I'm a droid. Can I help you?

k2so.power_on
True

k2so.switch_off()
Bye! I'm going to sleep

k2so.power_on
False



<Importante>

Siempre que queramos acceder a cualquier m√©todo o atributo del 
objeto habr√° que utilizar la palabra self.

[Inicializaci√≥n]

Existe un m√©todo especial que se ejecuta cuando creamos una 
instancia de un objeto. Este m√©todo es __init__ y nos permite 
asignar atributos y realizar operaciones con el objeto en el 
momento de su creaci√≥n. 
Tambi√©n es ampliamente conocido como el constructor.

Veamos un ejemplo de este m√©todo con nuestros droides en el que 
√∫nicamente guardaremos el nombre del droide como un atributo del 
objeto:

class Droid:

    def __init__(self, name: str):
        self.name = name



droid = Droid('BB-8')

droid.name
'BB-8'

Es importante tener en cuenta que si no usamos self estaremos 
creando una variable local en vez de un atributo del objeto:

class Droid:

    def __init__(self, name: str):
        name = name  # No lo hagas!



droid = Droid('BB-8')

droid.name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Droid' object has no attribute 'name'

[Atributos]

Acceso directo

En el siguiente ejemplo vemos que, aunque el atributo name se 
ha creado en el constructor de la clase, tambi√©n podemos 
modificarlo desde ¬´fuera¬ª con un acceso directo:

class Droid:

    def __init__(self, name: str):
        self.name = name

droid = Droid('C-3PO')

droid.name
'C-3PO'

droid.name = 'waka-waka'  # esto ser√≠a v√°lido!




(Nota)

N√≥tese el acceso a los atributos con obj.attribute en vez de lo 
que ven√≠amos usando en diccionarios donde hay que escribir 
¬´un poco m√°s¬ª obj['attribute'].


(Propiedades)

Como hemos visto previamente, los atributos definidos en un objeto
son accesibles p√∫blicamente. Esto puede parecer extra√±o a personas
que vengan de otros lenguajes de programaci√≥n (v√©ase Java). En 
Python existe un cierto ¬´sentido de la responsabilidad¬ª a la 
hora de programar y manejar este tipo de situaciones: 
Casi todo es posible a priori pero se debe controlar 
expl√≠citamente.

Una posible soluci√≥n ¬´pit√≥nica¬ª para la privacidad de los 
atributos es el uso de propiedades. La forma m√°s com√∫n de 
aplicar propiedades es mediante el uso de decoradores:



@property para leer el valor de un atributo.

@name.setter para escribir el valor de un atributo.

Veamos un ejemplo en el que estamos ofuscando el nombre del 
droide a trav√©s de propiedades:

class Droid:

    def __init__(self, name: str):
        self.hidden_name = name

        @property
        def name(self) -> str:    
            print('inside the getter')   
            return self.hidden_name

        @name.setter
        def name(self, name: str) -> None:      
            print('inside the setter')        
            self.hidden_name = name

droid = Droid('N1-G3L')

droid.name
inside the getter
'N1-G3L'

droid.name = 'Nigel'
inside the setter

droid.name
inside the getter
'Nigel'

En cualquier caso, 
seguimos pudiendo acceder directamente a .hidden_name:

droid.hidden_name
'Nigel'

Incluso podemos cambiar su valor:

droid.hidden_name = 'waka-waka'

droid.name
inside the getter
'waka-waka'

(Valores calculados)

Una propiedad tambi√©n se puede usar para devolver un valor 
calculado (o computado).

Supongamos que la altura del periscopio de los droides 
astromec√°nicos se calcula siempre como un porcentaje de su altura. Veamos c√≥mo implementarlo:


class AstromechDroid:

    def __init__(self, name: str, height: float):
        self.name = name
        self.height = height

        @property
        def periscope_height(self) -> float:
            return 0.3 * self.height

droid = AstromechDroid('R2-D2', 1.05)

droid.periscope_height  # podemos acceder como atributo
0.315

droid.periscope_height = 10  # no podemos modificarlo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute

<Las propiedades @property no pueden recibir par√°metros ya que no>
<tiene sentido sem√°nticamente>

class AstromechDroid:

    def __init__(self, name: str, height: float):
        self.name = name
        self.height = height

    @property
    def periscope_height(self, from_ground: bool = False) -> float:    
        height_factor = 1.3 if from_ground else 0.3   
        return height_factor * self.height


droid = AstromechDroid('R2-D2', 1.05)

droid.periscope_height
0.315



droid.periscope_height(from_ground=True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'float' object is not callable


En este caso tendr√≠amos que implementar un m√©todo para resolver 
el escenario planteado.



Consejo

La ventaja de usar valores calculados sobre simples atributos es 
que el cambio de valor en un atributo no asegura que actualicemos 
otro atributo, y adem√°s siempre podremos modificar directamente 
el valor del atributo, con lo que podr√≠amos obtener efectos 
colaterales indeseados.

(Cacheando propiedades)

En los ejemplos anteriores hemos creado una propiedad que calcula 
el alto del periscopio de un droide astromec√°nico a partir de su 
altura. El ¬´coste¬ª de este c√°lculo es bajo, 
pero imaginemos por un momento que fuera muy alto.

Si cada vez que accedemos a dicha propiedad tenemos que realizar 
ese c√°lculo, estar√≠amos siendo muy ineficientes 
(en el caso de que la altura del droide no cambiara). Veamos una 
aproximaci√≥n a este escenario usando el cacheado de propiedades:


class AstromechDroid:

    def __init__(self, name: str, height: float):
        self.name = name
        self.height = height

    @height.setter
    def height(self, height: float) -> None:    
        self._periscope_height = None    
        self._height = height


    @property
    def periscope_height(self) -> float:
        if self._periscope_height is None:
            print('Calculating periscope height...')
            self._periscope_height = 0.3 * self.height    
        return self._periscope_height


Probamos ahora la implementaci√≥n dise√±ada, 
modificando la altura del droide:

droid = AstromechDroid('R2-D2', 1.05)

droid.periscope_height
Calculating periscope height...
0.315

droid.periscope_height  # Cacheado!
0.315

droid.height = 1.15

droid.periscope_height
Calculating periscope height...
0.345

droid.periscope_height  # Cacheado!
0.345


(Ocultando atributos)

Python tiene una convenci√≥n sobre aquellos atributos que queremos 
hacer ¬´privados¬ª (u ocultos): 
comenzar el nombre con doble subgui√≥n __

class Droid:

    def __init__(self, name: str):
        self.__name = name

droid = Droid('BC-44')

droid.__name  # efectivamente no aparece como atributo
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
AttributeError: 'Droid' object has no attribute '__name'


Lo que realmente ocurre tras el tel√≥n se conoce como 
¬´name mangling¬ª y consiste en modificar el nombre del 
atributo incorporado la clase como un prefijo. Sabiendo esto 
podemos acceder al valor del atributo supuestamente privado:

droid._Droid__name
'BC-44'




Nota

La filosof√≠a de Python permite hacer casi cualquier cosa con 
los objetos que se manejan, eso s√≠, el sentido de la 
responsabilidad se traslada a la persona que desarrolla e 
incluso a la persona que hace uso del objeto.

(Atributos de clase)


Podemos asignar atributos a las clases y ser√°n heredados por 
todos los objetos instanciados de esa clase.

A modo de ejemplo, en un principio, todos los droides est√°n dise√±ados para que obedezcan a su due√±o. Esto lo conseguiremos a nivel de clase, 
salvo que ese comportamiento se sobreescriba:

class Droid:

    obeys_owner = True  # obedece a su due√±o

good_droid = Droid()

good_droid.obeys_owner
True

t1000 = Droid()  # T-1000 (Terminator)

t1000.obeys_owner = False

t1000.obeys_owner
False

Droid.obeys_owner  # el cambio no afecta a nivel de clase
True




Truco

Los atributos de clase son accesibles tanto desde la clase como 
desde las instancias creadas.


<A tener en cuenta lo siguiente>:

Si modificamos un atributo de clase desde un objeto, 
s√≥lo modificamos el valor en el objeto y no en la clase.

Si modificamos un atributo de clase desde una clase, 
modificamos el valor en todos los objetos pasados y futuros.

Veamos un ejemplo de esto √∫ltimo:

class Droid:

    obeys_owner = True

droid1 = Droid()

droid1.obeys_owner
True

droid2 = Droid()

droid2.obeys_owner
True

Droid.obeys_owner = False  # cambia pasado y futuro

droid1.obeys_owner
False

droid2.obeys_owner
False

droid3 = Droid()

droid3.obeys_owner
False


(M√©todos)

<M√©todos de instancia>

Un m√©todo de instancia es un m√©todo que modifica o accede al 
estado del objeto al que hace referencia. Recibe self como primer 
par√°metro, el cual se convierte en el propio objeto sobre el que 
estamos trabajando. Python env√≠a este argumento de forma transparente:
no hay que pasarlo como argumento.

Veamos un ejemplo en el que, adem√°s del constructor, 
creamos un m√©todo de instancia para desplazar un droide:

class Droid:

    def __init__(self, name: str):  # m√©todo de instancia -> constructor
        self.name = name
        self.covered_distance = 0

    def move_up(self, steps: int) -> None:  # m√©todo de instancia
        self.covered_distance += steps
        print(f'Moving {steps} steps')

droid = Droid('C1-10P')

droid.move_up(10)
Moving 10 steps


(Propiedades vs M√©todos)

Es razonable plantearse cu√°ndo usar propiedades o cu√°ndo 
usar m√©todos de instancia.

((Si la implementaci√≥n requiere de par√°metros, no hay confusi√≥n, necesitamos usar m√©todos.))


(M√©todos de clase)

Un m√©todo de clase es un m√©todo que modifica o accede al estado de
la clase a la que hace referencia. Recibe cls como primer 
par√°metro, el cual se convierte en la propia clase sobre la que 
estamos trabajando. Python env√≠a este argumento de forma 
transparente. La identificaci√≥n de estos m√©todos se completa 
aplicando el decorador @classmethod a la funci√≥n.


Veamos un ejemplo en el que implementamos un m√©todo de clase que 
indica el n√∫mero de droides que hemos creado:

class Droid:

    count = 0


    def __init__(self):
        Droid.count += 1


    @classmethod
    def total_droids(cls) -> None:
        print(f'{cls.count} droids built so far!')


droid1 = Droid()
droid2 = Droid()
droid3 = Droid()

Droid.total_droids()
3 droids built so far!



(Consejo)

El nombre cls es s√≥lo una convenci√≥n. 
Este par√°metro puede llamarse de otra manera, pero seguir el 
est√°ndar ayuda a la legibilidad.


(M√©todos est√°ticos)

Un m√©todo est√°tico es un m√©todo que no ¬´deber√≠a¬ª modificar el 
estado del objeto ni de la clase. No recibe ning√∫n par√°metro 
especial. La identificaci√≥n de estos m√©todos se completa 
aplicando el decorador @staticmethod a la funci√≥n.


Veamos un ejemplo en el que creamos un m√©todo est√°tico para devolver 
las categor√≠as de droides que existen en StarWars:

lass Droid:

    def __init__(self):
        pass


        @staticmethod
        def get_droids_categories() -> tuple[str]:    
            return ('Messeger', 'Astromech', 'Power', 'Protocol')


Droid.get_droids_categories()
('Messeger', 'Astromech', 'Power', 'Protocol')


(METODOS DECORADOS)

Es posible que, seg√∫n el escenario, queramos decorar ciertos 
m√©todos de nuestra clase. Esto es posible siguiendo la misma 
estructura de decoradores que ya hemos visto, pero con ciertos 
matices.

A continuaci√≥n un ejemplo en el que creamos un decorador para 
auditar las acciones de un droide y saber qui√©n ha hecho qu√©:

class Droid:

    @staticmethod
    def audit(method):
        def wrapper(self, *args, **kwargs):
            print(f'Droid {self.name} running {method.__name__}')
            return method(self, *args, **kwargs)
        return wrapper

        def __init__(self, name: str):
            self.name = name
            self.pos = [0, 0]

            @audit
            def move(self, x: int, y: int):        
                self.pos[0] += x        
                self.pos[1] += y

                @audit
                def reset(self):
                    self.pos = [0, 0]


droid = Droid('B1')

droid.move(1, 1)
Droid B1 running move

droid.reset()
Droid B1 running reset

El decorador se puede poner dentro o fuera de la clase. 
Por una cuesti√≥n de encapsulamiento podr√≠a tener sentido 
dejarlo dentro de la clase como m√©todo est√°tico.



Truco

Tambi√©n es posible aplicar esta misma t√©cnica usando decoradores 
con par√°metros.

                  
                
            

(DECORADORES FUNCIONES)

Hay situaciones en las que necesitamos modificar el comportamiento 
de funciones existentes pero sin alterar su c√≥digo. 
Para estos casos es muy √∫til usar decoradores.

Un decorador es una funci√≥n que recibe como par√°metro una funci√≥n 
y devuelve otra funci√≥n. 
Se podr√≠a ver como un caso particular de clausura.

El esqueleto b√°sico de un decorador es el siguiente:

def my_decorator(func):
    def wrapper(*args, **kwargs):
        # some code before calling func
        return func(*args, **kwargs)
        # some code after calling func
    return wrapper

(Elemento)           (Descripci√≥n)
    
 my_decorator        Nombre del decorador
    
 wrapper             Funci√≥n interior (convenci√≥n de nombre)
    
  func               Funci√≥n a decorar (convenci√≥n de nombre)
    
  *args              Argumentos posicionales (convenci√≥n de nombre)
    
  **kwargs            Argumentos nominales (convenci√≥n de nombre)


  Veamos un ejemplo de decorador que convierte el resultado 
  num√©rico de una funci√≥n a su representaci√≥n binaria:

  def res2bin(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return bin(result)
    return wrapper

Ahora definimos una funci√≥n ordinaria 
(que usaremos m√°s adelante) y que computa ùë•ùëõ:

  def power(x: int, n: int) -> int:
    return x ** n 

    power(2, 3)
    8
    
    power(4, 5)
    1024
    
    Ahora aplicaremos el decorador definido previamente res2bin() 
    sobre la funci√≥n ordinaria power(). Se dice que res2bin() es 
    la funci√≥n decoradora y que power() es la funci√≥n decorada:

    decorated_power = res2bin(power)

    decorated_power(2, 3)  # 8
    '0b1000'

    decorated_power(4, 5)  # 1024
    '0b10000000000

(Usando @ para decorar)
Python nos ofrece un ¬´syntactic sugar¬ª para simplificar la 
aplicaci√≥n de los decoradores a trav√©s del operador @ justo 
antes de la definici√≥n de la funci√≥n que queremos decora

@res2bin
def power(x: int, n: int) -> int:
    return x ** n

    power(2, 3)
    '0b1000'
    
    power(4, 5)
    '0b10000000000'



(Clausuras)

Una clausura (del t√©rmino ingl√©s ¬´closure¬ª) establece el uso de una funci√≥n 
interior que se genera din√°micamente y recuerda los valores de los argumentos 
con los que fue creada:

def make_multiplier_of(n):
    def multiplier(x):
        return x * n
    return multiplier


(M√©todos m√°gicos)

Cuando escribimos 'hello world' * 3 ¬øc√≥mo sabe el objeto 
'hello world' lo que debe hacer para multiplicarse con el 
objeto entero 3? O dicho de otra forma, ¬øcu√°l es la 
implementaci√≥n del operador * para ¬´strings¬ª e ¬´int¬ª? 
En valores num√©ricos puede parecer evidente 
(siguiendo los operadores matem√°ticos), 
pero no es as√≠ para otros objetos. 
La soluci√≥n que proporciona Python para estas (y otras) 
situaciones son los m√©todos m√°gicos.

Los m√©todos m√°gicos empiezan y terminan por doble subgui√≥n 
__ (es por ello que tambi√©n se les conoce como ¬´dunder-methods¬ª). 
Uno de los ¬´dunder-methods¬ª m√°s famosos es el constructor de una 
clase: __init__().



Importante

Digamos que los m√©todos m√°gicos se ¬´disparan¬ª de manera 
transparente cuando utilizamos ciertas estructuras y 
expresiones del lenguaje.

Para el caso de los operadores, existe un m√©todo m√°gico asociado 
(que podemos personalizar). Por ejemplo la comparaci√≥n de dos 
objetos se realiza con el m√©todo __eq__():

Extrapolando esta idea a nuestro universo StarWars, 
podr√≠amos establecer que dos droides son iguales 
si su nombre es igual,
independientemente de que tengan distintos n√∫meros de serie:

class Droid:

    def __init__(self, name: str, serial_number: int):
        self.name = name
        self.serial_number = serial_number


    def __eq__(self, droid: Droid) -> bool:
        return self.name == droid.name



droid1 = Droid('C-3PO', 43974973242)
droid2 = Droid('C-3PO', 85094905984)

droid1 == droid2  # llamada impl√≠cita a __eq__
True

droid1.__eq__(droid2)
True



(Truco)
Para poder utilizar la anotaci√≥n de tipo Droid necesitamos a√±adir 
la siguiente l√≠nea al principio de nuestro c√≥digo:
from __future__ import annotations



Nota

Los m√©todos m√°gicos no s√≥lo est√°n restringidos a operadores de 
comparaci√≥n o matem√°ticos. Existen muchos otros en la 
documentaci√≥n oficial de Python, donde son llamados m√©todos 
especiales.


Veamos un ejemplo en el que ¬´sumamos¬ª dos droides 
(esto se podr√≠a ver como una fusi√≥n). Supongamos que la suma de 
dos droides implica: a) que el nombre del droide resultante es la
 concatenaci√≥n de los nombres de los droides de entrada; 
 b) que la energ√≠a del droide resultante es la suma de la energ√≠a 
 de los droides de entrada:

 class Droid:

 def __init__(self, name: str, power: int):
     self.name = name
     self.power = power


 def __add__(self, other: Droid) -> Droid:
     new_name = self.name + '-' + other.name
     new_power = self.power + other.power
     return Droid(new_name, new_power)  #Hay que devolver un objeto de tipo Droid

droid1 = Droid('C3PO', 45)
droid2 = Droid('R2D2', 91)

droid3 = droid1 + droid2

print(f'Fusion droid:\n{droid3.name} with power {droid3.power}')
Fusion droid:
C3PO-R2D2 with power 136



Importante

Este tipo de operaciones debe devolver un objeto de la clase con 
la que estamos trabajando.



Truco

En este tipo de m√©todos m√°gicos el par√°metro suele llamarse 
other haciendo referencia al ¬´otro¬ª objeto que entra en la 
operaci√≥n. Es una convenci√≥n.

(Sobrecarga de operadores)

¬øQu√© ocurrir√≠a si sumamos un n√∫mero entero a un droide? 
De primeras nada, porque no lo tenemos contemplado, 
pero podr√≠amos establecer un significado: 
Si sumamos un n√∫mero entero a un droide √©ste aumenta su energ√≠a 
en el valor indicado. Vamos a intentar a√±adir tambi√©n este 
comportamiento al operador suma ya implementado.

Aunque en Python no existe t√©cnicamente la 
¬´sobrecarga de funciones¬ª, s√≠ que podemos simularla 
identificando el tipo del objeto que nos pasan y realizando 
acciones en base a ello:

class Droid:

    def __init__(self, name: str, power: int):
        self.name = name
        self.power = power

        def __add__(self, other: Droid | int) -> Droid:
            if isinstance(other, Droid):
                new_name = self.name + '-' + other.name
                new_power = self.power + other.power
            elif isinstance(other, int):
                new_name = self.name
                new_power = self.power + other   
            return Droid(new_name, new_power)



droid = Droid('L3-37', 75)

powerful_droid = droid + 25

powerful_droid.power
100


Esta misma estrategia se puede aplicar al operador de igualdad 
ya que es muy habitual encontrar comparaciones de objetos en 
nuestro c√≥digo. Por ello, deber√≠amos tener en cuenta si se van 
a comparar dos objetos de distinta naturaleza.

Retomando el caso ya visto‚Ä¶ 
¬øqu√© pasar√≠a si comparamos un droide con una cadena de texto?

class Droid:
    def __init__(self, name: str, serial_number: int):
        self.name = name
        self.serial_number = serial_number


    def __eq__(self, droid: Droid) -> bool:
        return self.name == droid.name

droid = Droid('C-3PO', 43974973242)

droid == 'C-3PO'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in __eq__
AttributeError: 'str' object has no attribute 'name'


class Droid:

    def __init__(self, name: str, serial_number: int):
        self.name = name
        self.serial_number = serial_number


    def __eq__(self, other: Droid | object) -> bool:
        if isinstance(other, Droid):
            return self.name == droid.name
        return False

Ahora podemos comprobar que todo funciona como esperar√≠amos:

droid = Droid('C-3PO', 43974973242)

droid == 'C-3PO'
False

(__str__)

Uno de los m√©todos m√°gicos m√°s utilizados es __str__ y permite 
establecer la forma en la que un objeto es representado como 
cadena de texto:

class Droid:

    def __init__(self, name: str, serial_number: int):
        self.serial_number = serial_number
        self.name = name


    def __str__(self) -> str:
        return f'ü§ñ Droid "{self.name}" serial-no {self.serial_number}'

droid = Droid('K-2SO', 8403898409432)

print(droid)  # llamada a droid.__str__()
ü§ñ Droid "K-2SO" serial-no 8403898409432


str(droid)
'ü§ñ Droid "K-2SO" serial-no 8403898409432'

f'Droid -> {droid}'
'Droid -> ü§ñ Droid "K-2SO" serial-no 8403898409432'

(__repr__)

En ausencia del m√©todo __str__() se usar√° por defecto el m√©todo 
__repr__(). La diferencia entre ambos m√©todos es que el primero 
est√° m√°s pensado para una representaci√≥n del objeto de cara al 
usuario mientras que el segundo est√° m√°s orientado al desarrollador.

El m√©todo __repr()__ se invoca autom√°ticamente en los dos 
siguientes escenarios:

Cuando no existe el m√©todo __str__() en el objeto y tratamos 
de encontrar su representaci√≥n en cadena de texto con str() o 
print().

Cuando utilizamos el int√©rprete interactivo de Python y pedimos el ¬´valor¬ª del objeto.

Veamos un ejemplo. En primer lugar un droide que s√≥lo implementa el m√©todo __str__():

class Droid:
    def __init__(self, name: str):
        self.name = name


    def __str__(self):
        return f"Hi there! I'm {self.name}"


14 = Droid('C-14')

print(c14)  # __str()__
Hi there! I'm C-14

c14  # __repr()__
<__main__.Droid at 0x103d7cc10>

Ahora implementamos tambi√©n el m√©todo __repr__():

class Droid:

    def __init__(self, name: str):
        self.name = name


    def __str__(self):
        return f"Hi there! I'm {self.name}"


    def __repr__(self):
        return f"[Droid] '{self.name}' @ {hex(id(self))}"

c14 = Droid('C-14')

print(c14)
Hi there! I'm C-14

c14  # __repr__()
[Droid] 'C-14' @ 0x103e4e350



Atenci√≥n

El hecho de incorporar la direcci√≥n de memoria del objeto en 
el m√©todo __repr__() no es en absoluto obligatorio, ni 
siquiera necesario. Todo depende de los requerimientos que 
tengamos en el proyecto.

(Gestores de contexto)
