CONTROL DE FLUJO

Todo programa inform치tico est치 formado por instrucciones que se ejecutan en forma 
secuencial de 춺arriba췉 a 춺abajo췉, de igual manera que leer칤amos un libro. 
Este orden constituye el llamado flujo del programa. 
Es posible modificar este flujo secuencial para que tome bifurcaciones o repita ciertas instrucciones. Las 
sentencias que nos permiten hacer estas modificaciones se engloban en el control de flujo.


CONDICIONALES:

Definici칩n de bloques

A diferencia de otros lenguajes que utilizan llaves para definir los bloques de c칩digo, 
cuando Guido Van Rossum cre칩 el lenguaje quiso evitar estos caracteres por considerarlos innecesarios. 
Es por ello que en Python los bloques de c칩digo se definen a trav칠s de espacios en blanco, 
preferiblemente 4. 2 En t칠rminos t칠cnicos se habla del tama침o de indentaci칩n.

Comentarios

Los comentarios son anotaciones que podemos incluir en nuestro programa y que nos permiten aclarar ciertos aspectos del c칩digo. 
Estas indicaciones son ignoradas por el int칠rprete de Python.
Los comentarios se incluyen usando el s칤mbolo almohadilla # y comprenden hasta el final de la l칤nea.


Comentario en bloque

# Universe age expressed in days
universe_age = 13800 * (10 ** 6) * 365

Los comentarios tambi칠n pueden aparecer en la misma l칤nea de c칩digo, aunque la gu칤a de estilo de Python no aconseja usarlos en demas칤a:
Comentario en l칤nea

stock = 0   # Release additional articles

Ancho del c칩digo

Los programas suelen ser m치s legibles cuando las l칤neas no son excesivamente largas. La longitud m치xima de l칤nea recomendada por la gu칤a de estilo de Python es de 80 caracteres.
Sin embargo, esto genera una cierta pol칠mica hoy en d칤a, 
ya que los tama침os de pantalla han aumentado y las resoluciones son mucho mayores que hace a침os. 
As칤 las l칤neas de m치s de 80 caracteres se siguen visualizando correctamente. 
Hay personas que son m치s estrictas en este l칤mite y otras m치s flexibles.

En caso de que queramos romper una l칤nea de c칩digo demasiado larga, tenemos dos opciones:

Usar la barra invertida \:
>>>

factorial = 4 * 3 * 2 * 1

factorial = 4 * \

            3 * \

            2 * \

            1

Usar los par칠ntesis (...):
>>>

factorial = 4 * 3 * 2 * 1

factorial = (4 *

             3 *

             2 *

             1)


SENTENCIA IF

La sentencia if

La sentencia condicional en Python (al igual que en muchos otros lenguajes de programaci칩n) es if. 
En su escritura debemos a침adir una expresi칩n de comparaci칩n terminando con dos puntos al final de la l칤nea. 
Veamos un ejemplo:

temperature = 40

if temperature > 35:

    print('Aviso por alta temperatura')


Aviso por alta temperatura

Nota

N칩tese que en Python no es necesario incluir par칠ntesis ( y ) al escribir condiciones. Hay veces que es recomendable por claridad o por establecer prioridades.

En el caso anterior se puede ver claramente que la condici칩n se cumple y por tanto se ejecuta la instrucci칩n que tenemos dentro del cuerpo de la condici칩n. 
Pero podr칤a no ser as칤. Para controlar ese caso existe la sentencia else. 
Veamos el mismo ejemplo anterior pero a침adiendo esta variante:

temperature = 20

if temperature > 35:

    print('Aviso por alta temperatura')

else:

    print('Par치metros normales')


Par치metros normales

Podr칤amos tener incluso condiciones dentro de condiciones, 
lo que se viene a llamar t칠cnicamente condiciones anidadas . 
Veamos un ejemplo ampliando el caso anterior:

temperature = 28

if temperature < 20:

    if temperature < 10:

        print('Nivel azul')

    else:

        print('Nivel verde')

else:

    if temperature < 30:

        print('Nivel naranja')

    else:

        print('Nivel rojo')


Nivel naranja


Python nos ofrece una mejora en la escritura de condiciones anidadas cuando aparecen consecutivamente un else y un if. 
Podemos sustituirlos por la sentencia elif:

Apliquemos esta mejora al c칩digo del ejemplo anterior:

temperature = 28

if temperature < 20:

    if temperature < 10:

        print('Nivel azul')

    else:

        print('Nivel verde')

elif temperature < 30:

    print('Nivel naranja')

else:

    print('Nivel rojo')


Nivel naranja

ASIGNACIONES CONDICIONALES 

Supongamos que queremos asignar un nivel de riesgo de incendio en funci칩n de la temperatura. 
En su versi칩n cl치sica escribir칤amos:

temperature = 35

if temperature < 30:

    fire_risk = 'LOW'

else:

    fire_risk = 'HIGH'

fire_risk
'HIGH'

IMPORTANTE Sin embargo, esto lo podr칤amos abreviar con una asignaci칩n condicional de una 칰nica l칤nea:

fire_risk = 'LOW' if temperature < 30 else 'HIGH'

fire_risk
'HIGH'

Operadores de comparaci칩n

Cuando escribimos condiciones debemos incluir alguna expresi칩n de comparaci칩n. 
Para usar estas expresiones es fundamental conocer los operadores que nos ofrece Python:


	

Operador         S칤mbolo

Igualdad           ==

Desigualdad	       !=

Menor que           <

Menor o igual que   <=

Mayor que           >

Mayor o igual que   >=


A continuaci칩n vamos a ver una serie de ejemplos con expresiones de comparaci칩n. 
T칠ngase en cuenta que estas expresiones habr칤a que 
incluirlas dentro de la sentencia condicional en el caso de que quisi칠ramos tomar una acci칩n concreta:

Asignaci칩n de valor inicial
>>> value = 8

>>> value == 8
True

>>> value != 8
False

>>> value < 12
True

>>> value <= 7
False

>>> value > 4
True

>>> value >= 9
False

OPERADORES LOGICOS


Podemos escribir condiciones m치s complejas usando los operadores l칩gicos:

        and

        or

        not

# Asignaci칩n de valor inicial
>>> x = 8

>>> x > 4 or x > 12  # True or False
True

>>> x < 4 or x > 12  # False or False
False

>>> x > 4 and x > 12  # True and False
False

>>> x > 4 and x < 12  # True and True
True

>>> not(x != 8)  # not False
True

OJO

Python ofrece la posibilidad de ver si un valor est치 entre dos l칤mites de manera directa. 
As칤, por ejemplo, para descubrir si value est치 entre 4 y 12 har칤amos:

4 <= value <= 12
True



Nota

    Una expresi칩n de comparaci칩n siempre devuelve un valor booleano, es decir True o False.
    El uso de par칠ntesis, en funci칩n del caso, puede aclarar la expresi칩n de comparaci칩n.

Cortocircuito l칩gico

Es interesante comprender que las expresiones l칩gicas no se eval칰an por completo si se dan una serie de circunstancias. 
Aqu칤 es donde entra el concepto de cortocircuito que no es m치s que una forma de denominar a este escenario.

Supongamos un ejemplo en el que utilizamos un tel칠fono m칩vil que mide la bater칤a por la variable power de 0 a 100% y la cobertura 4G por la variable signal_4g de 0 a 100%.
Para poder enviar un mensaje por Telegram necesitamos tener al menos un 25% de bater칤a y al menos un 10% de cobertura:

power = 10

signal_4g = 60

power > 25 and signal_4g > 10
False

Dado que estamos en un and y la primera condici칩n power > 25 no se cumple, 
se produce un cortocircuito y no se sigue evaluando el resto de la expresi칩n porque ya se sabe que va a dar False.

Otro ejemplo. 
Para poder hacer una llamada VoIP necesitamos tener al menos un 40% de bater칤a o al menos un 30% de cobertura:

power = 50

signal_4g = 20

power > 40 or signal_4g > 30
True

Dado que estamos en un or y la primera condici칩n power > 40 se cumple, 
se produce un cortocircuito y no se sigue evaluando el resto de la expresi칩n porque ya se sabe que va a dar True.

Nota

Si no se produjera un cortocircuito en la evaluaci칩n de la expresi칩n, 
se seguir칤a comprobando todas las condiciones posteriores hasta llegar al final de la misma.


춺Booleanos췉 en condiciones

Cuando queremos preguntar por la veracidad de una determinada variable 춺booleana췉 en una condici칩n, 
la primera aproximaci칩n que parece razonable es la siguiente:

is_cold = True

if is_cold == True:

    print('Coge chaqueta')

else:

    print('Usa camiseta')

Coge chaqueta

Pero podemos simplificar esta condici칩n tal que as칤:

if is_cold:

    print('Coge chaqueta')

else:

    print('Usa camiseta')


Coge chaqueta

Hemos visto una comparaci칩n para un valor 춺booleano췉 verdadero (True). 
En el caso de que la comparaci칩n fuera para un valor falso lo har칤amos as칤:

is_cold = False

if not is_cold:  # Equivalente a if is_cold == False

    print('Usa camiseta')

else:

    print('Coge chaqueta')


Usa camiseta

De hecho, si lo pensamos, estamos reproduciendo bastante bien el lenguaje natural:

    Si hace fr칤o, coge chaqueta.

    Si no hace fr칤o, usa camiseta.

VALOR NULO

None es un valor especial de Python que almacena el valor nulo 4. 
Veamos c칩mo se comporta al incorporarlo en condiciones de veracidad:

value = None

if value:

    print('Value has some useful value')

else:

    # value podr칤a contener None, False (u otro)

    print('Value seems to be void')


Value seems to be void

Para distinguir None de los valores propiamente booleanos, 
se recomienda el uso del operador is. 
Veamos un ejemplo en el que tratamos de averiguar si un valor es nulo:

value = None

if value is None:

    print('Value is clearly None')

else:

    # value podr칤a contener True, False (u otro)

    print('Value has some useful value')


Value is clearly None


De igual forma, podemos usar esta construcci칩n para el caso contrario. 
La forma 춺pit칩nica췉 de preguntar si algo no es nulo es la siguiente:

value = 99

if value is not None:

    print(f'{value=}')


value=99

VERACIDAD 

Cuando trabajamos con expresiones que incorporan valores booleanos, se produce una conversi칩n 
impl칤cita que transforma los tipos de datos involucrados a valores True o False.
Lo primero que debemos entender de cara comprobar la veracidad son los valores que 
eval칰an a falso o eval칰an a verdadero.
Veamos las 칰nicas 춺cosas췉 que son evaluadas a False en Python:

bool(False)
False

bool(None)
False

bool(0)
False

bool(0.0)
False

bool('')  # cadena vac칤a
False

bool([])  # lista vac칤a
False

bool(())  # tupla vac칤a
False

bool({})  # diccionario vac칤o
False

bool(set())  # conjunto vac칤o
False

Importante

El resto de objetos son evaluados a True en Python.

Veamos algunos ejemplos que son evaluados a True en Python:
>>>

bool('False')
True

bool(' ')
True

bool(1e-10)
True

bool([0])
True

bool('游붅')
True

ASIGNACION LOGICA:
Es posible utilizar operadores l칩gicos en sentencias de asignaci칩n sacando partido de las tablas de la verdad que funcionan para estos casos.
Veamos un ejemplo de asignaci칩n l칩gica utilizando el operador or:

b = 0

c = 5

a = b or c

a
5
En la l칤nea resaltada podemos ver que se est치 aplicando una expresi칩n l칩gica, 
por lo tanto se aplica una conversi칩n impl칤cita de los valores enteros a valores 춺booleanos췉. 
En este sentido el valor 0 se eval칰a a falso y el valor 5 se eval칰a a verdadero. 
Como estamos en un or el resultado ser치 verdadero, 
que en este caso es el valor 5 asignado finalmente a la variable a.

Veamos el mismo ejemplo de antes pero utilizando el operador and:

b = 0

c = 5

a = b and c

a
0

SENTENCIA MATCH-CASE :

Comparando valores

En su versi칩n m치s simple, el 춺pattern matching췉 permite comparar un valor de entrada con una serie de literales. 
Algo as칤 como un conjunto de sentencias 춺if췉 encadenadas. 
Veamos esta aproximaci칩n mediante un ejemplo:

color = '#FF0000'

match color:

    case '#FF0000':

        print('游댮')

    case '#00FF00':

        print('游릭')

    case '#0000FF':

        print('游댯')


游댮

쯈u칠 ocurre si el valor que comparamos no existe entre las opciones disponibles? 
Pues en principio, 
nada, ya que este caso no est치 cubierto. Si lo queremos controlar, 
hay que a침adir una nueva regla utilizando el subgui칩n _ como patr칩n:

olor = '#AF549B'

match color:

    case '#FF0000':

        print('游댮')

    case '#00FF00':

        print('游릭')

    case '#0000FF':

        print('游댯')

    case _:

        print('Unknown color!')


Unknown color!

PATRONES AVANZADOS

La sentencia match-case va mucho m치s all치 de una simple comparaci칩n de valores. 
Con ella podremos deconstruir estructuras de datos, capturar elementos o mapear valores.

Para ejemplificar varias de sus funcionalidades, vamos a partir de una tupla que 
representar치 un punto en el plano (2 coordenadas) o en el espacio (3 coordenadas). 
Lo primero que vamos a hacer es detectar en qu칠 dimensi칩n se encuentra el punto:

point = (2, 5)

match point:

    case (x, y):

        print(f'({x},{y}) is in plane')

    case (x, y, z):

        print(f'({x},{y},{z}) is in space')


(2,5) is in plane


point = (3, 1, 7)

match point:

    case (x, y):

        print(f'({x},{y}) is in plane')

    case (x, y, z):

        print(f'({x},{y},{z}) is in space')


(3,1,7) is in space

En cualquier caso, esta aproximaci칩n permitir칤a un punto formado por 춺strings췉:

point = ('2', '5')

match point:

    case (x, y):

        print(f'({x},{y}) is in plane')

    case (x, y, z):

        print(f'({x},{y},{z}) is in space')


(2,5) is in plane


Por lo tanto, en un siguiente paso, 
podemos restringir nuestros patrones a valores enteros:

point = ('2', '5')

match point:

    case (int(), int()):

        print(f'{point} is in plane')

    case (int(), int(), int()):

        print(f'{point} is in space')

    case _:

        print('Unknown!')


Unknown!

point = (3, 9, 1)

match point:

    case (int(), int()):

        print(f'{point} is in plane')

    case (int(), int(), int()):

        print(f'{point} is in space')

    case _:

        print('Unknown!')


(3, 9, 1) is in space


Imaginemos ahora que nos piden calcular la distancia del punto al origen. 
Debemos tener en cuenta que, a priori, 
desconocemos si el punto est치 en el plano o en el espacio:

point = (8, 3, 5)

match point:

    case (int(x), int(y)):

        dist_to_origin = (x ** 2 + y ** 2) ** (1 / 2)

    case (int(x), int(y), int(z)):

        dist_to_origin = (x ** 2 + y ** 2 + z ** 2) ** (1 / 2)

    case _:

        print('Unknown!')



dist_to_origin
9.899494936611665


Con este enfoque, 
nos aseguramos que los puntos de entrada deben tener todas sus coordenadas 
como valores enteros:

point = ('8', 3, 5)  # N칩tese el 8 como "string"

match point:

    case (int(x), int(y)):

        dist_to_origin = (x ** 2 + y ** 2) ** (1 / 2)

    case (int(x), int(y), int(z)):

        dist_to_origin = (x ** 2 + y ** 2 + z ** 2) ** (1 / 2)

    case _:

        print('Unknown!')


Unknown!

Cambiando de ejemplo, veamos un fragmento de c칩digo en el que tenemos que comprobar 
la estructura de un bloque de autenticaci칩n definido mediante un diccionario. 
Los m칠todos v치lidos de autenticaci칩n son 칰nicamente dos: bien usando nombre de usuario y contrase침a, 
o bien usando correo electr칩nico y 춺token췉 de acceso. 
Adem치s, los valores deben venir en formato cadena de texto:

# Lista de diccionarios

auths = [

    {'username': 'sdelquin', 'password': '1234'},

    {'email': 'sdelquin@gmail.com', 'token': '4321'},

    {'email': 'test@test.com', 'password': 'ABCD'},

    {'username': 'sdelquin', 'password': 1234}

]

for auth in auths:

    print(auth)

    match auth:

        case {'username': str(username), 'password': str(password)}:

            print('Authenticating with username and password')

            print(f'{username}: {password}')

        case {'email': str(email), 'token': str(token)}:

            print('Authenticating with email and token')

            print(f'{email}: {token}')

        case _:

            print('Authenticating method not valid!')

    print('---')


{'username': 'sdelquin', 'password': '1234'}
Authenticating with username and password
sdelquin: 1234
---
{'email': 'sdelquin@gmail.com', 'token': '4321'}
Authenticating with email and token
sdelquin@gmail.com: 4321
---
{'email': 'test@test.com', 'password': 'ABCD'}
Authenticating method not valid!
---
{'username': 'sdelquin', 'password': 1234}
Authenticating method not valid!

Cambiando de ejemplo, a continuaci칩n veremos un c칩digo que nos indica si, 
dada la edad de una persona, puede beber alcohol:

age = 21

match age:

    case 0 | None:

        print('Not a person')

    case n if n < 17:

        print('Nope')

    case n if n < 22:

        print('Not in the US')

    case _:

        print('Yes')


Not in the US



En la l칤nea 4 podemos observar el uso del operador OR.
En las l칤neas 6 y 8 podemos observar el uso de condiciones dando lugar a cl치usulas guarda.

(OJO)OPERADOR MORSA:

A partir de Python 3.8 se incorpora el operador morsa 5 que 
permite unificar sentencias de asignaci칩n dentro de expresiones. 
Su nombre proviene de la forma que adquiere :=


Supongamos un ejemplo en el que computamos el per칤metro de una circunferencia, 
indicando al usuario 
que debe incrementarlo siempre y cuando no llegue a un m칤nimo establecido.

Versi칩n tradicional

radius = 4.25

perimeter = 2 * 3.14 * radius

if perimeter < 100:

    print('Increase radius to reach minimum perimeter')

    print('Actual perimeter: ', perimeter)


Increase radius to reach minimum perimeter
Actual perimeter:  26.69

VERSION OPERADOR MORSA :=

radius = 4.25

if (perimeter := 2 * 3.14 * radius) < 100:

    print('Increase radius to reach minimum perimeter')

    print('Actual perimeter: ', perimeter)


Increase radius to reach minimum perimeter
Actual perimeter:  26.69



Consejo

Como hemos comprobado, el operador morsa permite realizar asignaciones dentro de expresiones, 
lo que, en muchas ocasiones, permite obtener un c칩digo m치s compacto. 
Ser칤a conveniente encontrar un equilibrio entre la expresividad y la legibilidad.

